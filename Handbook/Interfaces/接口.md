<h1>接口 ( Interfaces )</h1>

<h2>目录</h2>

## 介绍

TypeScript的核心概念之一就是类型检测集中在值所拥有的外形（比如说，对于一个函数，TypeScript只关心传入参数的数据是否满足该参数的类型注释，而不关注传入的参数是否是真正应该被传入的值。假设因为开发者的疏忽导致传入的参数应该是obj1，而不是obj2，但由于obj2和obj1有着相同的属性名并且值类型合法，TypeScript同样认为合法）。

这也被称作“[鸭子类型](https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B)”或者叫做“[结构子类型化](https://www.python.org/dev/peps/pep-0544/)”。

在TypeScript中，接口的作用就是命名类型，并且为你的代码或第三方代码定义契约（其实就是约定）。

## 我们的第一个接口！

让我们由一个简单的例子来了解接口是如何工作的：

```ts
function printLabel(labeledObj: {
  label: string
}) {
  console.log(labeledObj.label);
}

let myObj = {
  size: 10,
  label: "Size 10 Object"
};
printLabel(myObj);
```

如上代码，类型检测器对`printLabel`函数进行检测，该函数接收一个对象参数，并包含一个`string`类型的`label`属性。注意，该对象参数实际上有用更多的属性，但是编译器仅会对声明类型注释的属性进行检查。然而，有些时候TypeScript却并不会这么宽松，在后面会稍做讲解。

下面，让我们使用`interface`语法来重写这个例子：

```ts
interface LabeledValue {
  label: string;
}

function printLabel(labeledObj: LabeledValue) {
  console.log(labeledObj.label);
}

let myObj = {
  size: 10,
  label: "Size 10 Object"
};
printLabel(myObj);
```

名为`LabeledValue`的接口，扮演着与之前未使用接口时，传入的参数对象起着相同的作用，就是描述对象要求。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 `printLabel`的对象实现了这个接口。在TypeScript中，仅会关注值所拥有的的外形。就像本章开头所说，只要传入的对象满足上面提到的必要条件，那么它就是被允许的。

同时需要指出的是，类型检测器并不需要传入的对象属性有着同接口定义中相同的顺序，只需要存在相应的属性并且其类型也合法。

## 可选属性 ( Optional Properties )

并不是所有的接口属性都是必需的。一些属性仅存在于特定条件下，或者说根本不存在。当我们在为一个函数创建类似“配置包（`option bags`）”模式的对象参数时，这些可选属性会变得十分实用。

下面是该模式的一个例子：

```ts
interface SquareConfig {
  color ? : string;
  width ? : number;
}

function createSquare(config: SquareConfig): {
  color: string;
  area: number
} {
  let newSquare = {
    color: "white",
    area: 100
  };
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({
  color: "black"
});
```

上述代码中，可选属性在属性名后加上一个`?`来进行声明。在之后的调用语句中我们可以看出，虽然并没有传入`width`，编译器也并不有抛出任何异常。

可选属性的好处在于，在对所有可能存在值进行描述，同时仍然能够防止传入非法属性。例如我们输入一个错误的属性名，TypeScript将会对该不存在的属性名进行错误提示：

```ts
interface SquareConfig {
  color ? : string;
  width ? : number;
}

function createSquare(config: SquareConfig): {
  color: string;
  area: number
} {
  let newSquare = {
    color: "white",
    area: 100
  };
  if (config.clor) {
    // Error: Property 'clor' does not exist on type 'SquareConfig'
    newSquare.color = config.clor;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({
  color: "black"
});
```

> 注意：`function createSquare(config: SquareConfig):`函数声明冒号后是该函数返回值的类型描述，在本例中，该函数的返回值接受一个对象，并且包含`color`和`area`两个必须的值，其中，`color`的类型注释为字符串，`area`的类型注释为数字。

## 只读属性 ( Readonly properties )

有些时候，一些属性仅在对象被创建时进行初始化，而不能在创建后进行修改。你可以通过`readonly`前置修饰符对属性进行声明：

```ts
interface Point {
  readonly x: number;
  readonly y: number;
}
```

让我们创建一个`Point`类型的字面量对象，并进行初始化。初始化完成后，`x`和`y`均不能再被修改。否则会触发编译错误：

```ts
let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error! Cannot assign to 'x' because it is a read-only property.
```

接下来让我们看一个只读数组的例子，`ReadonlyArray<T>`等同于没有任何方法（能使原始数组被改变）的`Array<T>`。通过该声明，我们能够保证只读数组被创建后不会被修改。这很重要，尤其是有事我们往往会忘记哪些数组方法会改变原始数组，哪些不会。当我们错误地使用了某一方法后，这些错误往往很难被定位。而只读修饰符完美地解决了这个问题。下面是一些例子：

```ts
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.slice(3); // OK. As slice method won't mutate the original array.
ro.push(5); // error! Property 'push' does not exist on type 'readonly number[]'
ro.length = 100; // error!
a = ro; // error!
```

我们注意到，最后一排代码，将只读数组整个复制给一个正常数组都是不合法的。但是，TypeScript允许我们使用类型断言来越权操作：

```ts
a = ro as number[]; // OK. 因为通过类型断言，相当于我们告诉了编译器：“trust me, I know what I’m doing.”
```

### 只读声明与常量声明 ( readonly vs const )

有时候我们会疑惑什么时候使用`readonly`，什么时候使用`const`，这很简单，只需要记住：声明变量时用`const`，声明属性时用`readonly`。

## 额外属性检测

在第一个接口例子中，除了接口定义的`label: string`属性外，TypeScript还允许我们传入了额外的`size: number`属性。我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。

但是，如果你传入的额外属性在接口定义中没有进行声明，那么这样的做法很可能导致潜在的错误。例如：

```ts
interface SquareConfig {
  color ? : string;
  width ? : number;
}

function createSquare(config: SquareConfig): {
  color: string;area: number
} {
  // ...
}

let mySquare = createSquare({
  colour: "red", // Mean to be 'color' instead!
  width: 100
});
```

上述代码中，我们注意到，`color`被拼写成了`colour`。在原生JavaScript中，这样的做法将导致相关代码不被执行，因为属性名拼写错了。当然，你也可以说这个程序是正确的，因为`width`和`color`属性是可选的，额外传入的`colour`属性并不重要（因为在函数体中根本未使用这个属性）。

但是，TypeScript认为这是存在代码中的一个潜在的bug。当被赋值给其他变量，或者作为参数被传入时，字面量对象会经过额外属性检测。如果一个字面量对象包含任何没有被声明的属性，TypeScript就会抛出这样的错误：

```ts
// error: Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });
```

当然，要绕过额外属性检测也非常简单。就像我们之前处理将只读数组赋值给可变数组变量时一样，那就是使用类型断言。

```ts
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

另外一个更好的方法就是，通过添加一个字符串索引签名，就可以方便地为该对象添加任何额外的属性（前提是你确定这些额外属性的用途）。拿上例来说，假使`SquareConfig`可以拥有其他任何类型的属性，我们可以这样编写：

```ts
interface SquareConfig {
  color ? : string;
  width ? : number;
  [propName: string]: any;
}
```

后边我们会讲到索引签名，但是在这里，一旦这样声明，除了`color`和`width`类型检测外，我们传入的任何其他属性，可以是任何类型，TypeScript不会对它们的类型进行检测。

然而绕过额外属性检测的终极办法是，将该对象复制给另外一个变量（请不要感到惊讶）：因为`squareOptions`不会接受额外属性检测，故而编译器不会进行任何相关的错误提示（当然，正常声明过的类型注释的属性仍然会接受类型检测）。

```ts
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
```

只要`squareOptions`和`SquareConfig`拥有共同的属性，则上述解决方案则能生效（因为类型检测是鸭子类型）。在上例中，倘若我们去掉`width`属性，编译则会进行错误提示，因为`squareOptions`没有任何同`SquareConfig`接口外形一致的属性。如下：

```ts
let squareOptions = { colour: "red" };
// error: Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.
let mySquare = createSquare(squareOptions);
```

> 注意：对于上述简单的代码来说，你也许不应该试图“绕过”这些检测，因为一共就只会有几个属性。而对于更加复杂的除属性外还包含若干方法的字面量对象，你可能需要这些技巧。但是大部分的额外属性检测错误是真正的bug。这意味着，当对像'option bags'这类接口进行额外属性检测时得到错误时，你也许需要去自行校验一下代码中的类型声明。只要你在`SquareConfig`接口中进行声明，你也可以传入一个同时包含`color`和`colour`属性的对象给`createSquare`函数。

## 函数类型 ( Function Types )

接口能够描述任何JavaScript对象能够描述的外形。除属性外，接口也能够描述函数类型。

