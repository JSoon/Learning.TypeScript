<h1>联合和交叉类型 (Unions and Intersection Types)</h1>

<h2>目录</h2>


## 介绍

目前为止，手册内容涵盖了所有的原子类型（即基础类型，类，函数，接口，字面量类型）。但是，随着越来越多的类型被创建，我们发现需要一些工具来对现有的类型进行组合，而不是从头开始创建一个新的类型。

基于这样的考虑，交叉和联合类型便应运而生了。

## 联合类型 (Union Types)

有时候，当我们使用库函数时，这个函数可能期望传入一个`number`或者`string`类型的参数。例如：

```ts
/**
 * Takes a string and adds "padding" to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 */
function padLeft(value: string, padding: any) {
  if (typeof padding === "number") {
    // 若padding类型是数字，则在value前拼接padding数量的空格
    return Array(padding + 1).join(" ") + value;
  }
  if (typeof padding === "string") {
    // 若padding类型是字符串，则直接将该字符串拼接到原字符串前
    return padding + value;
  }
  throw new Error(`Expected string or number, got '${padding}'.`);
}

padLeft("Hello world", 4); // returns "    Hello world"
```

上例的问题在于，由于`padding: any`的类型。所以即使传入的参数类型不是`number`或者`string`，TypeScript也认为该类型是合法的。所以错误会在JavaScript执行时被抛出而非编译阶段：

```ts
// passes at compile time, fails at runtime.
// 错误！Uncaught Error: Expected string or number, got 'true'.
let indentedString = padLeft("Hello world", true);
```

在传统的面向对象语言中，我们可以通过创建层级类型将两种类型进行抽象。虽然这样实现更加精确，但同时也有点“大炮打蚊子”的感觉。原始版本的`padLeft`的优点在于，我们只传入原子类型的参数（因为是`any`）。这种用法简单明了。同时，新方法（联合类型）对已经存在的函数同样不会有什么帮助（这很好理解，因为已经存在的函数已经对该参数进行了逻辑处理，我们再通过联合类型来进行声明其实没有多大意义）。

下面是使用联合类型对上例进行了改写：

```ts
/**
 * Takes a string and adds "padding" to the left.
 * If 'padding' is a string, then 'padding' is appended to the left side.
 * If 'padding' is a number, then that number of spaces is added to the left side.
 * If 'padding' is a boolean, then ... (do whatever u want)
 */
function padLeft(value: string, padding: string | number | boolean) {
  // ...
}

// 正确
let indentedString = padLeft("Hello world", true);
```

### 带


